// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var Grpc = require("grpc");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Future = require("reason-future/src/Future.bs.js");
var Js_int = require("bs-platform/lib/js/js_int.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var BsGrpcDecoderError = Caml_exceptions.create("Grpc.BsGrpcDecoderError");

var ImpossibleError = Caml_exceptions.create("Grpc.ImpossibleError");

var GrpcClientRpcInvokeError = Caml_exceptions.create("Grpc.GrpcClientRpcInvokeError");

function futureFlatMapArray(f, maxConcurrent, xs) {
  return Future.make((function (resolve) {
                var result = Belt_Array.make(xs.length, /* None */0);
                var xlen = xs.length;
                var numJobs = [0];
                var cursor = [0];
                var pump = function () {
                  if (cursor[0] === xlen) {
                    if (numJobs[0] === 0) {
                      Curry._1(resolve, $$Array.map(Belt_Option.getExn, result));
                    }
                    
                  } else {
                    var i = cursor[0];
                    cursor[0] = cursor[0] + 1 | 0;
                    numJobs[0] = numJobs[0] + 1 | 0;
                    Future.get(Curry._1(f, Caml_array.caml_array_get(xs, i)), (function (x) {
                            Caml_array.caml_array_set(result, i, /* Some */[x]);
                            numJobs[0] = numJobs[0] - 1 | 0;
                            return pump(/* () */0);
                          }));
                  }
                  return /* () */0;
                };
                for(var _for = 1 ,_for_finish = maxConcurrent < xlen ? maxConcurrent : xlen; _for <= _for_finish; ++_for){
                  pump(/* () */0);
                }
                return /* () */0;
              }));
}

function arrayFirst(f, _n, a) {
  while(true) {
    var n = _n;
    var match = n < a.length;
    if (match) {
      var match$1 = Curry._1(f, Caml_array.caml_array_get(a, n));
      if (match$1) {
        return /* Some */[Caml_array.caml_array_get(a, n)];
      } else {
        _n = n + 1 | 0;
        continue ;
      }
    } else {
      return /* None */0;
    }
  };
}

function optCall(x, f) {
  if (x) {
    return Curry._1(f, x[0]);
  } else {
    return /* () */0;
  }
}

function reply(callback, x) {
  return callback(null, x, undefined, undefined);
}

var MissingFieldError = Caml_exceptions.create("Grpc.Validation.MissingFieldError");

var StringTooLongError = Caml_exceptions.create("Grpc.Validation.StringTooLongError");

var StringTooShortError = Caml_exceptions.create("Grpc.Validation.StringTooShortError");

var ArrayTooShortError = Caml_exceptions.create("Grpc.Validation.ArrayTooShortError");

var FractionalNumberError = Caml_exceptions.create("Grpc.Validation.FractionalNumberError");

var WrongStringError = Caml_exceptions.create("Grpc.Validation.WrongStringError");

var UnimplementedError = Caml_exceptions.create("Grpc.Validation.UnimplementedError");

var WrongNumberError = Caml_exceptions.create("Grpc.Validation.WrongNumberError");

var NumberOutOfRangeError = Caml_exceptions.create("Grpc.Validation.NumberOutOfRangeError");

var NumberNotPositiveError = Caml_exceptions.create("Grpc.Validation.NumberNotPositiveError");

var RegexMatchError = Caml_exceptions.create("Grpc.Validation.RegexMatchError");

var TransFieldError = Caml_exceptions.create("Grpc.Validation.TransFieldError");

function transFieldError(errMsg) {
  return /* Error */Block.__(1, [[
              TransFieldError,
              errMsg
            ]]);
}

function fieldMap(f, param) {
  return /* Field */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function fieldGet(param) {
  return param[1];
}

function futureMap(a, b) {
  return Future.map(b, a);
}

function futureFlatMap(a, b) {
  return Future.map(b, a);
}

function resultMap(a, b) {
  return Belt_Result.map(b, a);
}

function resultFlatMap(a, b) {
  return Belt_Result.flatMap(b, a);
}

function optionMap(a, b) {
  return Belt_Option.map(b, a);
}

function optionFlatMap(a, b) {
  return Belt_Option.flatMap(b, a);
}

function resultOptionFlatMap(f, x) {
  if (x.tag) {
    return x;
  } else {
    var match = x[0];
    if (match) {
      return Curry._1(f, match[0]);
    } else {
      return x;
    }
  }
}

function okSome(x) {
  return /* Ok */Block.__(0, [/* Some */[x]]);
}

function error(e) {
  return /* Error */Block.__(1, [e]);
}

function value(fieldName, x) {
  return /* Field */[
          fieldName,
          Future.value(/* Ok */Block.__(0, [x]))
        ];
}

function fieldValidatorOfMessageValidator(f, param) {
  return /* Field */[
          param[0],
          Future.flatMapOk(param[1], (function (x) {
                  if (x) {
                    return Future.mapOk(Future.mapError(Curry._1(f, x[0]), (function (str) {
                                      return [
                                              TransFieldError,
                                              str
                                            ];
                                    })), (function (x) {
                                  return /* Some */[x];
                                }));
                  } else {
                    return Future.value(/* Ok */Block.__(0, [/* None */0]));
                  }
                }))
        ];
}

function numberRange(lo, hi) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = Caml_obj.caml_lessequal(lo, x) && Caml_obj.caml_lessequal(x, hi);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [NumberOutOfRangeError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function maxNumber(param) {
  return numberRange(Js_int.min, param);
}

function minNumber(n) {
  return numberRange(n, Js_int.max);
}

function isEqualNumber(n) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = Caml_obj.caml_equal(x, n);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [WrongNumberError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function isEqualString(s) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = Caml_obj.caml_equal(x, s);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [WrongStringError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function isInt(param) {
  return fieldMap((function (param) {
                return Future.map(param, (function (param) {
                              return resultOptionFlatMap((function (x) {
                                            var match = Math.trunc(x) === x;
                                            if (match) {
                                              return /* Ok */Block.__(0, [/* Some */[x]]);
                                            } else {
                                              return /* Error */Block.__(1, [FractionalNumberError]);
                                            }
                                          }), param);
                            }));
              }), param);
}

function notEqualNumber(n) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = Caml_obj.caml_notequal(x, n);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [WrongNumberError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function notEqualString(s) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = Caml_obj.caml_equal(s, x);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [WrongStringError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function matchRegex(re) {
  var re$1 = new RegExp(re);
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = re$1.test(x);
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [RegexMatchError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function required(x) {
  return fieldMap((function (param) {
                return Future.map(param, (function (x) {
                              if (!x.tag && !x[0]) {
                                return /* Error */Block.__(1, [MissingFieldError]);
                              } else {
                                return x;
                              }
                            }));
              }), x);
}

function maxStrLen(len) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = x.length <= len;
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [StringTooLongError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

function minStrLen(len) {
  return (function (param) {
      return fieldMap((function (param) {
                    return Future.map(param, (function (param) {
                                  return resultOptionFlatMap((function (x) {
                                                var match = x.length >= len;
                                                if (match) {
                                                  return /* Ok */Block.__(0, [/* Some */[x]]);
                                                } else {
                                                  return /* Error */Block.__(1, [StringTooShortError]);
                                                }
                                              }), param);
                                }));
                  }), param);
    });
}

var nonEmptyString = minStrLen(1);

function trimString(param) {
  return fieldMap((function (param) {
                return Future.map(param, (function (param) {
                              return Belt_Result.map(param, (function (param) {
                                            return Belt_Option.map(param, (function (prim) {
                                                          return prim.trim();
                                                        }));
                                          }));
                            }));
              }), param);
}

var positive = numberRange(1, Js_int.max);

function repeated(f, param) {
  var fieldName = param[0];
  var foo = function (x) {
    if (x) {
      var bar = futureFlatMapArray((function (x) {
              return Future.mapOk(fieldGet(Curry._1(f, /* Field */[
                                  fieldName,
                                  Future.value(/* Ok */Block.__(0, [/* Some */[x]]))
                                ])), Belt_Option.getExn);
            }), 2147483647, x[0]);
      return Future.mapOk(Future.map(bar, (function (x) {
                        var firstError = arrayFirst(Belt_Result.isError, 0, x);
                        if (firstError) {
                          var match = firstError[0];
                          if (match.tag) {
                            return /* Error */Block.__(1, [match[0]]);
                          } else {
                            throw [
                                  ImpossibleError,
                                  "found unfound element"
                                ];
                          }
                        } else {
                          return /* Ok */Block.__(0, [$$Array.map(Belt_Result.getExn, x)]);
                        }
                      })), (function (x) {
                    return /* Some */[x];
                  }));
    } else {
      return Future.value(/* Ok */Block.__(0, [/* None */0]));
    }
  };
  var future = Future.flatMapOk(param[1], foo);
  return /* Field */[
          fieldName,
          future
        ];
}

function minItemCount(len, x) {
  return fieldMap((function (param) {
                return Future.map(param, (function (x) {
                              if (x.tag) {
                                return x;
                              } else {
                                var match = x[0];
                                if (match) {
                                  var x$1 = match[0];
                                  var match$1 = x$1.length < len;
                                  if (match$1) {
                                    return /* Error */Block.__(1, [ArrayTooShortError]);
                                  } else {
                                    return /* Ok */Block.__(0, [/* Some */[x$1]]);
                                  }
                                } else {
                                  return x;
                                }
                              }
                            }));
              }), x);
}

function maxItemCount(len, x) {
  return fieldMap((function (param) {
                return Future.map(param, (function (x) {
                              if (x.tag) {
                                return x;
                              } else {
                                var match = x[0];
                                if (match) {
                                  var x$1 = match[0];
                                  var match$1 = x$1.length > len;
                                  if (match$1) {
                                    return /* Error */Block.__(1, [ArrayTooShortError]);
                                  } else {
                                    return /* Ok */Block.__(0, [/* Some */[x$1]]);
                                  }
                                } else {
                                  return x;
                                }
                              }
                            }));
              }), x);
}

function err2msg(param) {
  if (param === MissingFieldError) {
    return "required field missing";
  } else if (param === StringTooLongError) {
    return "string value too long";
  } else if (param === StringTooShortError) {
    return "string value too short";
  } else if (param === NumberNotPositiveError) {
    return "number value non-positive";
  } else if (param === ArrayTooShortError) {
    return "not enough items";
  } else if (param === FractionalNumberError) {
    return "number is fractional";
  } else if (param === WrongStringError) {
    return "string mismatch";
  } else if (param === UnimplementedError) {
    return "unimplemented validation";
  } else if (param === WrongNumberError) {
    return "wrong number";
  } else if (param === NumberOutOfRangeError) {
    return "number ouf ot range";
  } else if (param === RegexMatchError) {
    return "string pattern mismatch";
  } else if (param[0] === TransFieldError) {
    return "involving multiple fields: " + param[1];
  } else {
    return "unknown error";
  }
}

function fold(param, happy, sad) {
  var fieldName = param[0];
  return Curry._1(param[1][0], (function (x) {
                if (x.tag) {
                  return Curry._2(sad, fieldName, err2msg(x[0]));
                } else {
                  return Curry._1(happy, x[0]);
                }
              }));
}

var Validation = /* module */[
  /* MissingFieldError */MissingFieldError,
  /* StringTooLongError */StringTooLongError,
  /* StringTooShortError */StringTooShortError,
  /* ArrayTooShortError */ArrayTooShortError,
  /* FractionalNumberError */FractionalNumberError,
  /* WrongStringError */WrongStringError,
  /* UnimplementedError */UnimplementedError,
  /* WrongNumberError */WrongNumberError,
  /* NumberOutOfRangeError */NumberOutOfRangeError,
  /* NumberNotPositiveError */NumberNotPositiveError,
  /* RegexMatchError */RegexMatchError,
  /* TransFieldError */TransFieldError,
  /* transFieldError */transFieldError,
  /* fieldMap */fieldMap,
  /* fieldGet */fieldGet,
  /* futureMap */futureMap,
  /* futureFlatMap */futureFlatMap,
  /* resultMap */resultMap,
  /* resultFlatMap */resultFlatMap,
  /* optionMap */optionMap,
  /* optionFlatMap */optionFlatMap,
  /* resultOptionFlatMap */resultOptionFlatMap,
  /* okSome */okSome,
  /* error */error,
  /* value */value,
  /* fieldValidatorOfMessageValidator */fieldValidatorOfMessageValidator,
  /* numberRange */numberRange,
  /* maxNumber */maxNumber,
  /* minNumber */minNumber,
  /* isEqualNumber */isEqualNumber,
  /* isEqualString */isEqualString,
  /* isInt */isInt,
  /* notEqualNumber */notEqualNumber,
  /* notEqualString */notEqualString,
  /* matchRegex */matchRegex,
  /* required */required,
  /* maxStrLen */maxStrLen,
  /* minStrLen */minStrLen,
  /* nonEmptyString */nonEmptyString,
  /* trimString */trimString,
  /* positive */positive,
  /* repeated */repeated,
  /* minItemCount */minItemCount,
  /* maxItemCount */maxItemCount,
  /* err2msg */err2msg,
  /* fold */fold
];

var ServerKeyAndCert = /* module */[];

var myProtoHandle = Grpc.load("extend.proto").tin_extend;

var Tin_extend = /* module */[/* myProtoHandle */myProtoHandle];

var myProtoHandle$1 = Grpc.load("assemblyline.proto").assemblyline;

function widgetConditionOfInt(x) {
  if (x !== 0) {
    if (x !== 1) {
      throw [
            BsGrpcDecoderError,
            "bs-grpc encountered invalid WidgetCondition enum value " + (String(x) + "")
          ];
    } else {
      return /* WidgetConditionDefective */1;
    }
  } else {
    return /* WidgetConditionAdequate */0;
  }
}

function intOfWidgetCondition(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

var WidgetCondition = /* module */[
  /* widgetConditionOfInt */widgetConditionOfInt,
  /* intOfWidgetCondition */intOfWidgetCondition
];

function t(condition, _) {
  var tmp = { };
  var tmp$1 = Belt_Option.map(condition, intOfWidgetCondition);
  if (tmp$1) {
    tmp.condition = tmp$1[0];
  }
  return tmp;
}

function condition(x) {
  return Belt_Option.map(Js_primitive.undefined_to_opt(x.condition), widgetConditionOfInt);
}

function make(condition, _) {
  return t(condition, /* () */0);
}

function validate(x) {
  return Future.make((function (resolve) {
                var conditionRef = [condition(x)];
                var n = [1];
                var failed = [false];
                var fail = function (fieldName, errMsg) {
                  failed[0] = true;
                  return Curry._1(resolve, /* Error */Block.__(1, ["error validating field " + (String(fieldName) + (": " + (String(errMsg) + "")))]));
                };
                fold(required(value("condition", conditionRef[0])), (function (param) {
                        var field = conditionRef;
                        var y = param;
                        if (failed[0]) {
                          return 0;
                        } else {
                          field[0] = y;
                          n[0] = n[0] - 1 | 0;
                          if (n[0] === 0) {
                            return fold(required(value("BlankWidget", /* Some */[t(conditionRef[0], /* () */0)])), (function (opt) {
                                          return Curry._1(resolve, /* Ok */Block.__(0, [Belt_Option.getExn(opt)]));
                                        }), fail);
                          } else {
                            return 0;
                          }
                        }
                      }), fail);
                return /* () */0;
              }));
}

var codec = myProtoHandle$1.BlankWidget;

var encode = codec.encode;

var decode = codec.decode;

function encode$1(x) {
  return Curry._3(encode, x, undefined, undefined).toBuffer();
}

function decode$1(x) {
  return Curry._3(decode, x, undefined, undefined);
}

var BlankWidget = /* module */[
  /* t */t,
  /* condition */condition,
  /* make */make,
  /* validate */validate,
  /* codec */codec,
  /* encode */encode$1,
  /* decode */decode$1
];

function t$1(condition, numTeeth, _) {
  var tmp = { };
  var tmp$1 = Belt_Option.map(condition, intOfWidgetCondition);
  if (tmp$1) {
    tmp.condition = tmp$1[0];
  }
  if (numTeeth) {
    tmp.numTeeth = numTeeth[0];
  }
  return tmp;
}

function condition$1(x) {
  return Belt_Option.map(Js_primitive.undefined_to_opt(x.condition), widgetConditionOfInt);
}

function make$1(condition, numTeeth, _) {
  return t$1(condition, numTeeth, /* () */0);
}

function validate$1(x) {
  return Future.make((function (resolve) {
                var conditionRef = [condition$1(x)];
                var numTeethRef = [Js_primitive.undefined_to_opt(x.numTeeth)];
                var n = [2];
                var failed = [false];
                var fail = function (fieldName, errMsg) {
                  failed[0] = true;
                  return Curry._1(resolve, /* Error */Block.__(1, ["error validating field " + (String(fieldName) + (": " + (String(errMsg) + "")))]));
                };
                var tick = function (field, y) {
                  if (failed[0]) {
                    return 0;
                  } else {
                    field[0] = y;
                    n[0] = n[0] - 1 | 0;
                    if (n[0] === 0) {
                      return fold(required(value("CutWidget", /* Some */[t$1(conditionRef[0], numTeethRef[0], /* () */0)])), (function (opt) {
                                    return Curry._1(resolve, /* Ok */Block.__(0, [Belt_Option.getExn(opt)]));
                                  }), fail);
                    } else {
                      return 0;
                    }
                  }
                };
                fold(required(value("condition", conditionRef[0])), (function (param) {
                        return tick(conditionRef, param);
                      }), fail);
                fold(numberRange(32, 63)(required(value("numTeeth", numTeethRef[0]))), (function (param) {
                        return tick(numTeethRef, param);
                      }), fail);
                return /* () */0;
              }));
}

var codec$1 = myProtoHandle$1.CutWidget;

var encode$2 = codec$1.encode;

var decode$2 = codec$1.decode;

function encode$3(x) {
  return Curry._3(encode$2, x, undefined, undefined).toBuffer();
}

function decode$3(x) {
  return Curry._3(decode$2, x, undefined, undefined);
}

var CutWidget = /* module */[
  /* t */t$1,
  /* condition */condition$1,
  /* make */make$1,
  /* validate */validate$1,
  /* codec */codec$1,
  /* encode */encode$3,
  /* decode */decode$3
];

function widgetColorOfInt(x) {
  if (x > 2 || x < 0) {
    throw [
          BsGrpcDecoderError,
          "bs-grpc encountered invalid WidgetColor enum value " + (String(x) + "")
        ];
  } else {
    return x;
  }
}

function intOfWidgetColor(param) {
  return param;
}

var WidgetColor = /* module */[
  /* widgetColorOfInt */widgetColorOfInt,
  /* intOfWidgetColor */intOfWidgetColor
];

function t$2(condition, numTeeth, paintJob, _) {
  var tmp = { };
  var tmp$1 = Belt_Option.map(condition, intOfWidgetCondition);
  if (tmp$1) {
    tmp.condition = tmp$1[0];
  }
  if (numTeeth) {
    tmp.numTeeth = numTeeth[0];
  }
  var tmp$2 = Belt_Option.map(paintJob, intOfWidgetColor);
  if (tmp$2) {
    tmp.paintJob = tmp$2[0];
  }
  return tmp;
}

function condition$2(x) {
  return Belt_Option.map(Js_primitive.undefined_to_opt(x.condition), widgetConditionOfInt);
}

function paintJob(x) {
  return Belt_Option.map(Js_primitive.undefined_to_opt(x.paintJob), widgetColorOfInt);
}

function make$2(condition, numTeeth, paintJob, _) {
  return t$2(condition, numTeeth, paintJob, /* () */0);
}

function validate$2(x) {
  return Future.make((function (resolve) {
                var conditionRef = [condition$2(x)];
                var numTeethRef = [Js_primitive.undefined_to_opt(x.numTeeth)];
                var paintJobRef = [paintJob(x)];
                var n = [3];
                var failed = [false];
                var fail = function (fieldName, errMsg) {
                  failed[0] = true;
                  return Curry._1(resolve, /* Error */Block.__(1, ["error validating field " + (String(fieldName) + (": " + (String(errMsg) + "")))]));
                };
                var tick = function (field, y) {
                  if (failed[0]) {
                    return 0;
                  } else {
                    field[0] = y;
                    n[0] = n[0] - 1 | 0;
                    if (n[0] === 0) {
                      return fold(required(value("PaintedWidget", /* Some */[t$2(conditionRef[0], numTeethRef[0], paintJobRef[0], /* () */0)])), (function (opt) {
                                    return Curry._1(resolve, /* Ok */Block.__(0, [Belt_Option.getExn(opt)]));
                                  }), fail);
                    } else {
                      return 0;
                    }
                  }
                };
                fold(required(value("condition", conditionRef[0])), (function (param) {
                        return tick(conditionRef, param);
                      }), fail);
                fold(numberRange(32, 63)(required(value("numTeeth", numTeethRef[0]))), (function (param) {
                        return tick(numTeethRef, param);
                      }), fail);
                fold(required(value("paintJob", paintJobRef[0])), (function (param) {
                        return tick(paintJobRef, param);
                      }), fail);
                return /* () */0;
              }));
}

var codec$2 = myProtoHandle$1.PaintedWidget;

var encode$4 = codec$2.encode;

var decode$4 = codec$2.decode;

function encode$5(x) {
  return Curry._3(encode$4, x, undefined, undefined).toBuffer();
}

function decode$5(x) {
  return Curry._3(decode$4, x, undefined, undefined);
}

var PaintedWidget = /* module */[
  /* t */t$2,
  /* condition */condition$2,
  /* paintJob */paintJob,
  /* make */make$2,
  /* validate */validate$2,
  /* codec */codec$2,
  /* encode */encode$5,
  /* decode */decode$5
];

function make$3(paintedWidgets, _) {
  var tmp = { };
  if (paintedWidgets) {
    tmp.paintedWidgets = paintedWidgets[0];
  }
  return tmp;
}

function validate$3(x) {
  return Future.make((function (resolve) {
                var paintedWidgetsRef = [Js_primitive.undefined_to_opt(x.paintedWidgets)];
                var n = [1];
                var failed = [false];
                var fail = function (fieldName, errMsg) {
                  failed[0] = true;
                  return Curry._1(resolve, /* Error */Block.__(1, ["error validating field " + (String(fieldName) + (": " + (String(errMsg) + "")))]));
                };
                fold(repeated((function (param) {
                            return fieldValidatorOfMessageValidator(validate$2, param);
                          }), value("paintedWidgets", paintedWidgetsRef[0])), (function (param) {
                        var field = paintedWidgetsRef;
                        var y = param;
                        if (failed[0]) {
                          return 0;
                        } else {
                          field[0] = y;
                          n[0] = n[0] - 1 | 0;
                          if (n[0] === 0) {
                            var tmp = { };
                            var tmp$1 = paintedWidgetsRef[0];
                            if (tmp$1) {
                              tmp.paintedWidgets = tmp$1[0];
                            }
                            return fold(required(value("BoxOfWidgets", /* Some */[tmp])), (function (opt) {
                                          return Curry._1(resolve, /* Ok */Block.__(0, [Belt_Option.getExn(opt)]));
                                        }), fail);
                          } else {
                            return 0;
                          }
                        }
                      }), fail);
                return /* () */0;
              }));
}

var codec$3 = myProtoHandle$1.BoxOfWidgets;

var encode$6 = codec$3.encode;

var decode$6 = codec$3.decode;

function encode$7(x) {
  return Curry._3(encode$6, x, undefined, undefined).toBuffer();
}

function decode$7(x) {
  return Curry._3(decode$6, x, undefined, undefined);
}

var BoxOfWidgets = /* module */[
  /* make */make$3,
  /* validate */validate$3,
  /* codec */codec$3,
  /* encode */encode$7,
  /* decode */decode$7
];

var Assemblyline = /* module */[
  /* myProtoHandle */myProtoHandle$1,
  /* WidgetCondition */WidgetCondition,
  /* BlankWidget */BlankWidget,
  /* CutWidget */CutWidget,
  /* WidgetColor */WidgetColor,
  /* PaintedWidget */PaintedWidget,
  /* BoxOfWidgets */BoxOfWidgets
];

function make$4(rootCert, privateKey, certChain) {
  return Grpc.ServerCredentials.createSsl(rootCert, /* array */[{
                private_key: privateKey,
                cert_chain: certChain
              }], true);
}

var Ssl = /* module */[/* make */make$4];

var Insecure = /* module */[];

var Credentials = /* module */[
  /* Ssl */Ssl,
  /* Insecure */Insecure
];

function make$5(credentials, host) {
  var server = new Grpc.Server();
  server.bind(host, credentials);
  server.start();
  return server;
}

var Server = /* module */[
  /* Credentials */Credentials,
  /* make */make$5
];

function set(t, key, value) {
  t.set(key, value);
  return t;
}

var Generator = /* module */[];

var Metadata = /* module */[
  /* set */set,
  /* Generator */Generator
];

var Credentials$1 = /* module */[];

var Client = /* module */[
  /* Metadata */Metadata,
  /* Credentials */Credentials$1
];

exports.BsGrpcDecoderError = BsGrpcDecoderError;
exports.ImpossibleError = ImpossibleError;
exports.GrpcClientRpcInvokeError = GrpcClientRpcInvokeError;
exports.futureFlatMapArray = futureFlatMapArray;
exports.arrayFirst = arrayFirst;
exports.optCall = optCall;
exports.reply = reply;
exports.Validation = Validation;
exports.ServerKeyAndCert = ServerKeyAndCert;
exports.Tin_extend = Tin_extend;
exports.Assemblyline = Assemblyline;
exports.Server = Server;
exports.Client = Client;
/* nonEmptyString Not a pure module */
